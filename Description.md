# Отчет

Интересное задание. Давно не приходилось продумывать структуру БД, как и писать, не задумываясь о производительности.

На первый взгляд задача очень простая. Я бы сказал на 16-20 часов максимум. На деле же, это время ушло только на написание тестов.


## ПО

Специально взял Django 1.8 + DRF 3.x, чтобы вы уже могли сравнить с Tastypie и сказать, что лучше.


## Об архитектуре БД

Большая часть моделей (таблиц) соответствуют своему названию. Они очень простые. Это модели, описывающие "адрес" (ДЦ, здание, этаж, ..).


### компоненты

Признаюсь, я вначале не обратил внимания, что компоненты являются атомарными. Я подумал, что они представляет из себя абстракцию (например, HDD: WD/1Tb/3.5"/SAS). Потом мы говорим, что у нас есть 20 таких HDD и в тот момент, когда компонент устанавливается в сервер, количество HDD уменьшается. Если бы в ТЗ не было указано поле "серийный номер", я бы так и реализовал.

Модель "Component" является абстракцией. Она описывает все типы компонентов (hdd, cpu, ram, raid, net, etc). Тип компонента указывается в поле "kind".

Характеристики (свойства) (модель Property) являются динамическими. В зависимости от типа компонента они могут быть сгруппированы (модель PropertyGroup). Например, чтобы получить список свойств для компонента типа "hdd", надо сделать следующее:

```python
group = PropertyGroup.objects.get(name='hdd')
hdd_properties = group.properties.all()
```

Значения характеристик хранятся в модели "ComponentPropertyValue".
Свойства могут быть 3-х типов: текст, число, значение из списка. Последний тип реализуется через модель "PropertyOption".

TODO: Можно вынести производителя компонента в отдельную модель. Это второстепенная задача, поэтому оставил на потом.


### типы (шаблоны) серверов

Вначале планировал сделать определение спецификации шаблона через свойства (по аналогии с компонентами), но из-за особенностей типа HDD, пришлось отказаться от этой затей (времени много уйдет).

Реализация очень простая. Модель "ServerTemplate" описывает типы серверов. Особенность с HDD решается с помощью отдельной модели "ServerTemplateHdd". Поскольку свойства заранее определены и я знаю их тип, значения задаются через ссылку на модель "PropertyOption".


### сервера/корзины

С серверами/корзинами все просто. Они определены в моделях "Server" и "Basket" соответственно.

Для того, чтобы разместить сервер/корзину в стойке, используется абстракция "юнит" (модель "Unit"). То есть сервер/корзина размещается в юните, а юнит уже в стойке.

По этой же аналогии реализовано размещение серверов в корзине. Только используется модель "BasketSlot".

Из-за этой особенности обнаружился один баг/фича с пунктом 3.5 ТЗ: при отображении свободных юнитов учитываются только юниты стойки, но при этом игнорируются свободные слоты в корзинах.
Есть еще один баг: отсутствие проверки типа сервера при его установке в корзину/стойку.


### стойки

В модели "Rack" есть поле "max_gap". Оно используется для поиска:
- стоек со свободными юнитами;
- стоек со свободными юнитами, в который влезет сервер/корзина высотой "height" юнитов (то есть стоек, в который влезет, например, 4U-сервер);
- пустых стоек;
- заполненных стоек.

Значение вычисляется автоматически при добавлении сервера/корзины в стойку.


## Тесты

Тестами покрыто где-то 70%. В основном, это задачи из ТЗ.


## Формат вывода данных

Большого опыта в проектировании API нету, поэтому возвращаемое значение может не соответствовать ожиданиям. Вообще, это отдельная тема для холивара. К счастью, DRF позволяет достаточно просто подправить формат сериализации.


## Проверка работы

Обнаружил, что фича DRF "Web browsable API" - не самый лучший способ тестировать API, особенно через "HTML форму". Он отображает не все поля, а иногда не так, как надо (особенно при наличии отношений между таблицами).

В написанных тестах, возможно, будет сложно разобраться. Поэтому можно попробовать "httpie", как предлагает DRF (http://www.django-rest-framework.org/tutorial/1-serialization/), либо проверенный временем "curl".

### запуск

Запустить можно 2-мя способами: vagrant или самому создать virtualenv.

Для использования Vagrant должны быть устновлены:
- vagrant
- virtualbox

Возможно также должен быть установлен "ansible". Хотя в этой конфигурации не должен требовать.

На Mac'e все можно поставить через Homebrew.

#### с помощью Vagrant:
$ git clone https://github.com/baffolobill/mb_test_1.git
$ cd mb_test_1
$ vagrant up

Может попросить ввести пароль для монтирования nfs. По этой же причине может упасть.

Все. После чего заходим в браузере: http://localhost:8083/ или http://localhost:8083/admin/.


#### с помощью virtualenv:
$ virtualenv --no-site-packages blah_blah_blah
$ cd blah_blah_blah
$ source bin/activate
$ mkdir current && cd current
$ git clone https://github.com/baffolobill/mb_test_1.git
$ cd src
$ python manage.py migrate
$ python manage.py loaddata initial_data.json
$ python manage.py runserver

Для входа в админку логин/пароль: admin/test


## Документация

Пока нет. Допишу по запросу.
